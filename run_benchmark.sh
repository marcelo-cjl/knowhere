#!/bin/bash
#
# Knowhere Benchmark Script
# =========================
#
# Dataset Directory Structure:
#   /home/ubuntu/data/<dataset_name>/
#     ├── <dataset_name>.fbin          # Base vectors (float32 binary format)
#     ├── <dataset_name>_query.fbin    # Query vectors (float32 binary format)
#     └── <dataset_name>_query_*_<topk>.truth  # Ground truth (generated by this script)
#
# Binary File Format (.fbin):
#   - First 4 bytes: number of vectors (uint32)
#   - Next 4 bytes: dimension (uint32)
#   - Remaining: float32 vector data (num_vectors * dim * 4 bytes)
#
# Supported Datasets (configured in DATASETS variable):
#   - gist:768:L2         - GIST descriptors, 768-dim, L2 distance
#   - cohere:768:COSINE   - Cohere embeddings, 768-dim, Cosine similarity
#   - sift:128:L2         - SIFT descriptors, 128-dim, L2 distance
#   - openai:1536:COSINE  - OpenAI embeddings, 1536-dim, Cosine similarity
#
# Index Types:
#   - GPU_CAGRA    : NVIDIA CAGRA graph index (GPU-built, CPU-searchable with adapt_for_cpu)
#   - GPU_VAMANA   : GPU Vamana/DiskANN index (GPU-built, CPU-searchable with adapt_for_cpu)
#   - HNSW_SQ      : HNSW with Scalar Quantization and refine
#   - HNSWLIB_DEPRECATED : Original hnswlib implementation
#
# Output Files:
#   - output.txt  : Raw benchmark output with all logs
#   - result.txt  : Parsed summary with QPS, recall, etc.
#

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$SCRIPT_DIR/build/Release"

BM="./tests/ut/knowhere_benchmark"
OUTPUT="$SCRIPT_DIR/output.txt"
RESULT="$SCRIPT_DIR/result.txt"

# Clear output files
echo "=== Benchmark Raw Output ===" > "$OUTPUT"
echo "Date: $(date)" >> "$OUTPUT"
echo "" >> "$OUTPUT"

echo "=== Benchmark Results ===" > "$RESULT"
echo "Date: $(date)" >> "$RESULT"
echo "" >> "$RESULT"
printf "%-10s %-20s %-12s %-12s %-10s %-10s\n" "Dataset" "Index" "Build(s)" "QPS" "Recall" "AvgNbrs" >> "$RESULT"
printf "%-10s %-20s %-12s %-12s %-10s %-10s\n" "-------" "-----" "--------" "---" "------" "-------" >> "$RESULT"

# Function to run benchmark
run_benchmark() {
    local dataset=$1
    local index=$2
    local label=$3
    local extra_args=$4

    echo ""
    echo "========================================"
    echo "Running: $dataset $label $extra_args"
    echo "========================================"

    # Run benchmark with tee to show in terminal and save to output.txt
    $BM --dataset "$dataset" --index "$index" --topk 100 --times 10 $extra_args 2>&1 | tee -a "$OUTPUT"
}

# Dataset configurations: "name:dim:metric"
# DATASETS="siftsmall:128:L2 cohere:768:COSINE gist:768:L2 openaismall:1536:COSINE"
DATASETS="cohere:768:COSINE"

# NN_DESCENT_NITER values to test
NN_DESCENT_NITER_VALUES="20 40 60 80 100"

# VAMANA_ITERS values to test
VAMANA_ITERS_VALUES="1 2"

EF_VALUES="100 120 140 160 180 200 220 240 260 280 300"

REFINE_K_VALUES="1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0"

HNSW_SQ_CONFIGS="sq4u:fp16"

# Run benchmarks for each dataset
for ds_config in $DATASETS; do
    IFS=':' read -r ds dim metric <<< "$ds_config"

    # Generate ground truth if not exists
    truth_file="/home/ubuntu/data/$ds/${ds}_query_*_100.truth"
    if ls $truth_file 1>/dev/null 2>&1; then
        echo "Ground truth for $ds already exists, skipping..."
    else
        echo "Generating ground truth for $ds..."
        $BM --mode truth --dataset $ds --topk 100 2>&1 | tee -a "$OUTPUT"
    fi

    echo "" >> "$RESULT"
    echo "# $ds ($dim dim, $metric)" >> "$RESULT"

    for niter in $NN_DESCENT_NITER_VALUES; do
        for ef in $EF_VALUES; do
            run_benchmark "$ds" "GPU_CAGRA" "CAGRA_D64_iter${niter}_ef${ef}" "--adapt_for_cpu --nn_descent_niter $niter --ef $ef"
        done
    done

    for niter in $VAMANA_ITERS_VALUES; do
        for ef in $EF_VALUES; do
            run_benchmark "$ds" "GPU_VAMANA" "VAMANA_D64_iter${niter}_ef${ef}" "--adapt_for_cpu --vamana_iters $niter --ef $ef"
        done
    done

    for sq_config in $HNSW_SQ_CONFIGS; do
        IFS=':' read -r sq_type refine_type <<< "$sq_config"
        for refine_k in $REFINE_K_VALUES; do
            label="HNSW_SQ_${sq_type}_r${refine_k}"
            run_benchmark "$ds" "HNSW_SQ" "$label" "--sq_type $sq_type --refine_k $refine_k --refine_type $refine_type"
        done
    done

    for ef in $EF_VALUES; do
        run_benchmark "$ds" "HNSWLIB_DEPRECATED" "HNSWLIB_M32_ef${ef}" "--ef $ef"
    done
    
done

echo ""
echo "=== All benchmarks completed ==="
echo ""

# Extract results from output.txt to result.txt
echo "Extracting results from output.txt..."

# Parse output.txt and extract metrics for each run
while IFS= read -r line; do
    if [[ "$line" =~ dataset=([a-z0-9_]+).*index=([A-Z_0-9]+) ]]; then
        dataset="${BASH_REMATCH[1]}"
        label="${BASH_REMATCH[2]}"
        ef=""
        has_refine_k=""
    elif [[ "$line" =~ sq_type=([a-z0-9]+).*refine_k=([0-9.]+).*refine_type=([a-z0-9]+) ]]; then
        # HNSW_SQ specific: capture sq_type and refine_k for label
        sq_type="${BASH_REMATCH[1]}"
        refine_k="${BASH_REMATCH[2]}"
        label="${label}_${sq_type}_r${refine_k}"
        has_refine_k="1"
    elif [[ "$line" =~ ef=([0-9]+) ]]; then
        # Capture ef value
        ef="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ build_time=([0-9.]+)s.*qps=([0-9.]+) ]]; then
        build_time="${BASH_REMATCH[1]}"
        qps="${BASH_REMATCH[2]}"
    elif [[ "$line" =~ avg_recall=([0-9.]+) ]]; then
        recall="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ \[INDEX_STATS\]\ avg_neighbors=([0-9.]+) ]]; then
        avg_neighbors="${BASH_REMATCH[1]}"
    elif [[ "$line" =~ max_disterr= ]] && [[ -n "$dataset" ]]; then
        if [[ -n "$ef" ]] && [[ -z "$has_refine_k" ]]; then
            label="${label}_ef${ef}"
        fi
        printf "%-10s %-20s %-12s %-12s %-10s %-10s\n" "$dataset" "$label" "${build_time:--}" "${qps:--}" "${recall:--}" "${avg_neighbors:--}" >> "$RESULT"
        # Reset for next run
        dataset=""
        label=""
        build_time=""
        qps=""
        recall=""
        avg_neighbors=""
        ef=""
        has_refine_k=""
    fi
done < "$OUTPUT"

echo "" >> "$RESULT"
echo "=== Done ===" >> "$RESULT"

echo ""
echo "Raw output saved to: $OUTPUT"
echo "Summary results saved to: $RESULT"
echo ""
cat "$RESULT"
